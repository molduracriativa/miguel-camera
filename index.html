<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Miguel 1 ano â€” Frame Story</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;width:100%;background:#000;font-family:Arial,Helvetica,sans-serif;overflow:hidden}
  /* Video preview */
  #video{position:absolute;inset:0;width:100vw;height:100vh;object-fit:cover;z-index:1;background:#000;transform-origin:center}
  /* Overlay (visual) keeps aspect with contain */
  #overlay{position:absolute;inset:0;width:100vw;height:100vh;object-fit:contain;pointer-events:none;z-index:2}
  /* Controls */
  #controls{position:absolute;left:50%;bottom:28px;transform:translateX(-50%);display:flex;gap:14px;z-index:30}
  .btn{width:68px;height:68px;border-radius:50%;border:none;background:#fff;font-size:26px;display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,.35)}
  /* start camera explicit (for iOS) */
  #startCam{position:absolute;left:50%;top:16px;transform:translateX(-50%);z-index:35;padding:8px 14px;border-radius:8px;border:none;background:#2196F3;color:#fff;font-weight:600;cursor:pointer}
  /* Preview area */
  #preview{position:absolute;left:50%;bottom:24px;transform:translateX(-50%);display:none;flex-direction:column;align-items:center;gap:8px;z-index:40}
  #photo,#video-play{width:86vw;max-width:360px;border-radius:10px;border:3px solid #fff;background:#000}
  .action{padding:10px 18px;border-radius:8px;border:none;background:#2196F3;color:#fff;cursor:pointer;font-weight:600}
  .danger{background:#ff3b30}
  #info{color:#fff;font-size:13px;text-align:center;margin-top:6px;display:none}
  /* small responsive tweaks */
  @media(min-width:900px){ #photo,#video-play{max-width:500px} }
</style>
</head>
<body>

<!-- Camera preview -->
<video id="video" autoplay playsinline muted></video>

<!-- Visual overlay (moldura.png) -->
<img id="overlay" src="moldura.png" alt="Moldura">

<!-- Canvas (oculto) para compor frames com a moldura -->
<canvas id="canvas" style="display:none"></canvas>

<!-- Start camera (Ãºtil em iOS quando autoplay bloqueado) -->
<button id="startCam">Iniciar cÃ¢mera</button>

<!-- Controls: switch, foto, gravar -->
<div id="controls">
  <button id="switchBtn" class="btn" title="Trocar cÃ¢mera">ðŸ”„</button>
  <button id="photoBtn" class="btn" title="Tirar foto">ðŸ“¸</button>
  <button id="recordBtn" class="btn" title="Gravar">ðŸŽ¥</button>
</div>

<!-- Preview (foto ou vÃ­deo) -->
<div id="preview">
  <img id="photo" style="display:none" alt="Foto com moldura">
  <video id="video-play" controls style="display:none"></video>
  <div style="display:flex;gap:10px">
    <button id="saveBtn" class="action">Salvar</button>
    <button id="retryBtn" class="action danger">Refazer</button>
  </div>
  <div id="info">No iPhone: toque e segure para salvar na Fototeca.</div>
</div>

<script>
/*
  CÃ³digo final otimizado:
  - moldura.png (1080x1920) com object-fit: contain
  - foto + vÃ­deo SALVOS com a moldura aplicada
  - preview frontal fica espelhado, arquivos finais NÃƒO ficam espelhados
  - start button para contornar autoplay bloqueado em iOS
*/

const videoEl = document.getElementById('video');
const overlayEl = document.getElementById('overlay');
const canvas = document.getElementById('canvas');

const startCamBtn = document.getElementById('startCam');
const switchBtn = document.getElementById('switchBtn');
const photoBtn = document.getElementById('photoBtn');
const recordBtn = document.getElementById('recordBtn');

const preview = document.getElementById('preview');
const photoEl = document.getElementById('photo');
const videoPlay = document.getElementById('video-play');
const saveBtn = document.getElementById('saveBtn');
const retryBtn = document.getElementById('retryBtn');
const info = document.getElementById('info');

let stream = null;
let usingFront = true;
let mediaRecorder = null;
let recordedChunks = [];
let drawInterval = null;

// espelhar apenas o preview
function setPreviewMirror(mirror){
  videoEl.style.transform = mirror ? 'scaleX(-1)' : 'none';
}

// tenta iniciar camera (pode ser chamado por startCamBtn)
async function startCamera(){
  if (stream) stream.getTracks().forEach(t => t.stop());
  const constraints = {
    video: {
      facingMode: usingFront ? 'user' : 'environment',
      width: { ideal: 1280 },
      height: { ideal: 720 }
    },
    audio: true
  };
  try {
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    videoEl.srcObject = stream;
    setPreviewMirror(usingFront);
    // esconder botÃ£o start se funcionar
    startCamBtn.style.display = 'none';
  } catch (err) {
    console.error('Erro ao iniciar cÃ¢mera:', err);
    alert('NÃ£o foi possÃ­vel acessar a cÃ¢mera. Verifique permissÃµes.');
  }
}

// Desenhar overlay com "contain" mantendo proporÃ§Ã£o (baseado na naturalWidth/naturalHeight da moldura)
function drawOverlayContain(ctx, canvasW, canvasH){
  const fw = overlayEl.naturalWidth || 1080;
  const fh = overlayEl.naturalHeight || 1920;
  const fr = fw / fh;
  const cr = canvasW / canvasH;
  let drawW, drawH, x, y;
  if (fr > cr){
    drawW = canvasW;
    drawH = canvasW / fr;
    x = 0;
    y = (canvasH - drawH) / 2;
  } else {
    drawH = canvasH;
    drawW = canvasH * fr;
    x = (canvasW - drawW) / 2;
    y = 0;
  }
  ctx.drawImage(overlayEl, x, y, drawW, drawH);
}

// Compor frame: desenha vÃ­deo (nÃ£o espelhado no resultado final) + overlay (contain)
function composeFrame(ctx, canvasW, canvasH){
  // preview pode estar espelhado por CSS; queremos o arquivo final NÃƒO espelhado
  const previewMirrored = (videoEl.style.transform || '').includes('scaleX(-1)');
  ctx.clearRect(0,0,canvasW,canvasH);

  if (previewMirrored){
    // desenha vÃ­deo invertendo horizontalmente para cancelar o espelho visual
    ctx.save();
    ctx.translate(canvasW, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(videoEl, 0, 0, canvasW, canvasH);
    ctx.restore();
  } else {
    ctx.drawImage(videoEl, 0, 0, canvasW, canvasH);
  }

  // overlay com contain
  drawOverlayContain(ctx, canvasW, canvasH);
}

// obtÃ©m tamanho de canvas baseado nas dimensÃµes reais do video element (ou fallback)
function getCanvasSize(){
  const vw = videoEl.videoWidth || 1080;
  const vh = videoEl.videoHeight || 1920;
  return { w: vw, h: vh };
}

/* ---------- FOTO ---------- */
photoBtn.addEventListener('click', async () => {
  if (!stream){
    await startCamera();
    if (!stream) return;
  }
  if (videoEl.readyState < 2) await new Promise(r => videoEl.onloadedmetadata = r);

  const { w, h } = getCanvasSize();
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.round(w * dpr);
  canvas.height = Math.round(h * dpr);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';

  const ctx = canvas.getContext('2d');
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(dpr, dpr);

  composeFrame(ctx, w, h);

  photoEl.src = canvas.toDataURL('image/png');
  photoEl.style.display = 'block';
  videoPlay.style.display = 'none';
  preview.style.display = 'flex';
  info.style.display = /iPhone|iPad|iPod/i.test(navigator.userAgent) ? 'block' : 'none';
});

/* ---------- GRAVAÃ‡ÃƒO ---------- */
recordBtn.addEventListener('click', async () => {
  if (!stream){
    await startCamera();
    if (!stream) return;
  }
  if (!mediaRecorder) startRecording();
  else stopRecording();
});

function startRecording(){
  if (videoEl.readyState < 2){
    videoEl.onloadedmetadata = () => startRecording();
    return;
  }

  const { w, h } = getCanvasSize();
  const dpr = Math.max(1, window.devicePixelRatio || 1);

  canvas.width = Math.round(w * dpr);
  canvas.height = Math.round(h * dpr);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';

  const ctx = canvas.getContext('2d');
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(dpr, dpr);

  // desenha frames constantemente
  drawInterval = setInterval(() => {
    composeFrame(ctx, w, h);
  }, 33);

  // pega stream do canvas (vÃ­deo) e adiciona Ã¡udio original se disponÃ­vel
  const canvasStream = canvas.captureStream(30);
  const audioTrack = stream.getAudioTracks()[0];
  if (audioTrack) canvasStream.addTrack(audioTrack);

  // criar MediaRecorder com fallbacks
  recordedChunks = [];
  let options = { mimeType: 'video/webm;codecs=vp9' };
  try {
    mediaRecorder = new MediaRecorder(canvasStream, options);
  } catch (e1) {
    try { mediaRecorder = new MediaRecorder(canvasStream, { mimeType: 'video/webm;codecs=vp8' }); }
    catch (e2) {
      try { mediaRecorder = new MediaRecorder(canvasStream, { mimeType: 'video/webm' }); }
      catch (e3) {
        // se chegar aqui, MediaRecorder nÃ£o Ã© suportado
        clearInterval(drawInterval);
        drawInterval = null;
        alert('GravaÃ§Ã£o de vÃ­deo nÃ£o Ã© suportada neste navegador. Atualize o navegador ou use Chrome/Safari recentes.');
        mediaRecorder = null;
        return;
      }
    }
  }

  mediaRecorder.ondataavailable = (ev) => { if (ev.data && ev.data.size) recordedChunks.push(ev.data); };

  mediaRecorder.onstop = () => {
    clearInterval(drawInterval);
    drawInterval = null;

    const blob = new Blob(recordedChunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);
    videoPlay.src = url;
    videoPlay.style.display = 'block';
    photoEl.style.display = 'none';
    preview.style.display = 'flex';
    info.style.display = /iPhone|iPad|iPod/i.test(navigator.userAgent) ? 'block' : 'none';

    mediaRecorder = null;
    recordBtn.style.background = '';
    recordBtn.title = 'Gravar';
  };

  mediaRecorder.start();
  // UI
  recordBtn.style.background = '#ff3b30';
  recordBtn.title = 'Parar';
}

function stopRecording(){
  if (mediaRecorder && mediaRecorder.state !== 'inactive'){
    mediaRecorder.stop();
  }
}

/* ---------- SALVAR / REFAZER ---------- */
saveBtn.addEventListener('click', () => {
  if (photoEl.style.display === 'block'){
    const a = document.createElement('a');
    a.href = photoEl.src;
    a.download = 'foto-moldura.png';
    a.click();
  } else if (videoPlay.style.display === 'block'){
    const a = document.createElement('a');
    a.href = videoPlay.src;
    a.download = 'video-moldura.webm';
    a.click();
  }
});

retryBtn.addEventListener('click', () => {
  preview.style.display = 'none';
  if (videoPlay.src && videoPlay.src.startsWith('blob:')) URL.revokeObjectURL(videoPlay.src);
  videoPlay.src = '';
  photoEl.src = '';
});

/* ---------- TROCAR CÃ‚MERA ---------- */
switchBtn.addEventListener('click', async () => {
  usingFront = !usingFront;
  await startCamera();
});

/* ---------- BOTÃƒO INICIAR CÃ‚MERA ---------- */
startCamBtn.addEventListener('click', async () => {
  await startCamera();
});

/* ---------- Inicia automaticamente se possÃ­vel, senÃ£o espera interaÃ§Ã£o do usuÃ¡rio ---------- */
overlayEl.addEventListener('load', () => {
  startCamera().catch(e => {
    // provÃ¡vel que iOS peÃ§a gesto do usuÃ¡rio â€” entÃ£o mostramos o botÃ£o start
    console.warn('Autostart falhou â€” aguarde interaÃ§Ã£o do usuÃ¡rio.', e);
    startCamBtn.style.display = 'block';
  });
});

/* ---------- Economiza recursos ao sair da aba ---------- */
document.addEventListener('visibilitychange', () => {
  if (document.hidden && drawInterval) {
    clearInterval(drawInterval);
    drawInterval = null;
  }
});
</script>
</body>
</html>
