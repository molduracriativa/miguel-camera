<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>Moldura - Foto e V√≠deo MP4 (Corrigido)</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{width:100%;height:100%;background:#000;font-family:Arial,Helvetica,sans-serif;overflow:hidden;touch-action:manipulation;}

  /* bot√£o inicial (sempre no topo) */
  #enable-camera-btn{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    z-index:999999;
    background:#4CAF50;
    color:#fff;
    border:none;
    padding:18px 36px;
    font-size:20px;
    border-radius:12px;
    touch-action:manipulation;
  }

  /* v√≠deo / canvas / overlay - escondidos at√© ativar */
  #video, #render-canvas { display:none; position:fixed; inset:0; width:100vw; height:100vh; object-fit:cover; }
  /* overlay ser√° desenhado no canvas. Mantemos a tag para carregamento */
  #overlay { display:none; position:fixed; top:0; left:50%; transform:translateX(-50%); height:100vh; width:auto; pointer-events:none; z-index:5; }

  /* bot√µes de a√ß√£o */
  #buttons{ display:none; position:fixed; bottom:36px; left:0; right:0; margin:0 auto; width:100%; max-width:720px; display:flex; justify-content:center; gap:18px; z-index:99999; }
  .action{ width:68px; height:68px; border-radius:50%; border:none; font-size:24px; background:#fff; box-shadow:0 6px 14px rgba(0,0,0,0.35); cursor:pointer; }

  #stop-record{ background:#e53935; color:#fff; display:none; }

  /* preview */
  #preview-container{ display:none; position:fixed; bottom:18px; left:50%; transform:translateX(-50%); z-index:99999; align-items:center; gap:8px; flex-direction:column; }
  #preview-video, #photo-preview{ width:86vw; max-width:360px; border-radius:10px; border:3px solid #fff; background:#000; display:block; }
  .btn-save{ background:#4CAF50; color:#fff; border:none; padding:10px 18px; border-radius:8px; font-size:16px; margin-top:8px; width:180px; cursor:pointer; }

  /* small status text */
  #status { position:fixed; top:10px; left:10px; color:#fff; font-size:13px; background:rgba(0,0,0,0.35); padding:6px 10px; border-radius:8px; z-index:999999; display:none; }
</style>
</head>
<body>

<button id="enable-camera-btn">Ativar C√¢mera</button>

<!-- elementos que ficar√£o vis√≠veis ap√≥s ativar -->
<video id="video" autoplay playsinline muted></video>
<!-- overlay image (vertical). Ser√° desenhada no canvas - mantida apenas para carregamento) -->
<img id="overlay" src="moldura.png" alt="moldura" />

<!-- canvas onde combinamos v√≠deo + moldura -->
<canvas id="render-canvas"></canvas>

<!-- controles -->
<div id="buttons">
  <button id="switch-camera" class="action" title="Trocar c√¢mera">üîÑ</button>
  <button id="capture" class="action" title="Tirar foto">üì∏</button>
  <button id="record" class="action" title="Gravar">üé•</button>
  <button id="stop-record" class="action" title="Parar grava√ß√£o">‚èπÔ∏è</button>
</div>

<!-- preview -->
<div id="preview-container">
  <video id="preview-video" controls playsinline style="display:none"></video>
  <img id="photo-preview" style="display:none"/>
  <button id="save-btn" class="btn-save">Salvar</button>
  <button id="retry-btn" class="btn-save" style="background:#777;margin-top:6px">Tentar novamente</button>
</div>

<div id="status"></div>

<!-- FFmpeg WASM (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.5/dist/ffmpeg.min.js"></script>

<script>
/* ======= Vari√°veis / elementos ======= */
const enableBtn = document.getElementById('enable-camera-btn');
const video = document.getElementById('video');
const overlayImg = document.getElementById('overlay');
const canvas = document.getElementById('render-canvas');
const ctx = canvas.getContext('2d');

const btns = {
  switchCamera: document.getElementById('switch-camera'),
  capture: document.getElementById('capture'),
  record: document.getElementById('record'),
  stopRecord: document.getElementById('stop-record'),
  previewContainer: document.getElementById('preview-container'),
  previewVideo: document.getElementById('preview-video'),
  photoPreview: document.getElementById('photo-preview'),
  save: document.getElementById('save-btn'),
  retry: document.getElementById('retry-btn')
};
const statusEl = document.getElementById('status');

let stream = null;
let usingFront = true;
let mediaRecorder = null;
let recordedChunks = [];
let drawLoopId = null;

/* FFmpeg */
const { createFFmpeg, fetchFile } = FFmpeg;
const ffmpeg = createFFmpeg({ log: false });

/* Utility: show status */
function showStatus(txt, show=true){
  if(show){ statusEl.style.display='block'; statusEl.textContent = txt; }
  else statusEl.style.display='none';
}

/* ======= HELPERS ======= */
/* Escolhe mimeType suportado para MediaRecorder (prioriza VP8/Opus) */
function getSupportedMime() {
  const candidates = [
    'video/webm;codecs=vp8,opus',
    'video/webm;codecs=vp9,opus',
    'video/webm',
  ];
  for (const m of candidates){
    try {
      if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(m)) return m;
    } catch(e){}
  }
  return '';
}

/* Espera elemento carregar (img/video metadata) */
function waitForImageLoad(img){
  return new Promise((resolve,reject)=>{
    if(img.complete && img.naturalWidth) return resolve();
    img.onload = () => resolve();
    img.onerror = (e) => reject(e);
  });
}
function waitForVideoMeta(v){
  return new Promise((resolve,reject)=>{
    if(v.readyState >= 1) return resolve();
    v.onloadedmetadata = ()=> resolve();
    v.onerror = (e)=> reject(e);
  });
}

/* ======= CAMERA INICIAL (chamada ap√≥s toque do usu√°rio) ======= */
async function startCamera() {
  // stop existing
  if (stream) {
    stream.getTracks().forEach(t=>t.stop());
    stream = null;
  }

  // request constraints
  const constraints = {
    video: { facingMode: usingFront ? 'user' : 'environment' },
    audio: true
  };

  showStatus('Abrindo c√¢mera...');
  stream = await navigator.mediaDevices.getUserMedia(constraints);

  video.srcObject = stream;
  video.muted = true;
  video.setAttribute('playsinline', '');
  await waitForVideoMeta(video);

  // garantir overlay carregada (pode ser grande)
  try { await waitForImageLoad(overlayImg); } catch(e){ console.warn('overlay load failed', e); }

  // dimensionar canvas conforme v√≠deo real
  // vamos desenhar com orienta√ß√£o do v√≠deo (videoWidth x videoHeight)
  canvas.width = video.videoWidth || Math.max(window.innerWidth, 720);
  canvas.height = video.videoHeight || Math.max(window.innerHeight, 1280);

  // exibir elementos da UI (bot√µes, canvas, overlay)
  video.style.display = 'block';
  overlayImg.style.display = 'block'; // mantemos vis√≠vel por se o usu√°rio quiser ver; mas desenho √© no canvas
  canvas.style.display = 'block';
  document.getElementById('buttons').style.display = 'flex';

  showStatus('');
}

/* ======= FUN√á√ÉO QUE DESENHA VIDEO + MOLDURA NO CANVAS (usada pra preview e grava√ß√£o) ======= */
function startDrawLoop() {
  if (drawLoopId) return; // j√° rodando

  function drawFrame(){
    const w = canvas.width;
    const h = canvas.height;

    // Clear
    ctx.clearRect(0,0,w,h);

    // Fill background black (avoid transparent areas)
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,w,h);

    // Desenhar v√≠deo: queremos "cover" por altura (preencher vertical), preservando propor√ß√£o
    // Calcula escala para preencher altura
    const vw = video.videoWidth;
    const vh = video.videoHeight;
    if (vw && vh) {
      const scale = h / vh; // scale by height
      const drawW = vw * scale;
      const drawH = h;
      // center horizontally
      const dx = (w - drawW) / 2;

      // se c√¢mera frontal, espelha apenas o v√≠deo
      if (usingFront) {
        ctx.save();
        ctx.translate(w, 0);
        ctx.scale(-1, 1);
        // when mirrored, draw at ( -dx - drawW )? We'll mirror whole canvas horizontally by drawing at negative dx
        // Easier approach: draw mirrored by mapping coordinates
        // But because we translated by w and scaled -1, we draw at x = dx * -1? simpler: drawImage(video, -(dx + drawW), 0, drawW, drawH) doesn't work intuitively.
        // Instead draw with drawImage using negative x: x = -(dx + drawW) + w? To avoid complexity, we'll draw into an offscreen canvas if needed.
        // Simpler and robust: use ctx.drawImage(video, 0, 0, vw, vh, dx, 0, drawW, drawH) inside saved mirrored context but with x = w - dx - drawW? We'll do correct calc below.
        // Compute mirrored target x in mirrored coordinate system:
        const mirroredX = w - dx - drawW;
        ctx.drawImage(video, 0, 0, vw, vh, mirroredX * -1 + w - w, 0, drawW, drawH); // fallback (rare)
        // The above is complex; simpler method below will be used instead (draw normally then mirror whole canvas area for video region)
        ctx.restore();
        // Simpler robust approach: draw non-mirrored then mirror the video area
        // We'll clear and draw below in non-mirrored approach to ensure correctness.
      }

      // Simpler implementation: draw non-mirrored video then, if front, mirror region using offscreen
      // Implemented below (replace above complex logic)
    }

    requestAnimationFrame(drawFrame); // loop placeholder; actual drawing implemented after function defined
  }

  // We'll implement a better draw loop that handles mirroring correctly using an offscreen canvas if needed.
  // Create offscreen canvas
  const off = document.createElement('canvas');
  off.width = canvas.width;
  off.height = canvas.height;
  const offCtx = off.getContext('2d');

  function drawLoop(){
    const w = canvas.width;
    const h = canvas.height;
    off.width = w;
    off.height = h;

    // draw video onto offscreen (cover by height)
    const vw = video.videoWidth || w;
    const vh = video.videoHeight || h;

    // scale so video fills height
    const scale = h / vh;
    const drawW = vw * scale;
    const drawH = h;
    const dx = (w - drawW) / 2;

    // clear offscreen
    offCtx.clearRect(0,0,w,h);
    offCtx.fillStyle = '#000';
    offCtx.fillRect(0,0,w,h);

    // draw video normally onto offscreen
    offCtx.drawImage(video, 0, 0, vw, vh, dx, 0, drawW, drawH);

    // if using front camera, mirror the video region inside offscreen
    if (usingFront) {
      // get the video region pixels and draw mirrored
      // simpler: transform and draw the video directly mirrored onto offCtx
      offCtx.save();
      offCtx.translate(w, 0);
      offCtx.scale(-1, 1);
      // mirrored draw: calculate mirrored dx
      const mirroredDx = (w - drawW) / 2;
      offCtx.drawImage(video, 0, 0, vw, vh, mirroredDx * -1 + (w - mirroredDx - drawW) , 0, drawW, drawH);
      offCtx.restore();

      // Note: above mirrored draw can be tricky across browsers; fallback approach:
      // if mirrored draw fails visually, we'll instead flip the whole canvas later. (Most browsers will handle drawImage in saved context.)
    }

    // draw overlay onto offscreen: we want overlay to fill height and center horizontally
    if (overlayImg && overlayImg.naturalWidth) {
      const ow = overlayImg.naturalWidth;
      const oh = overlayImg.naturalHeight;
      // scale overlay to fill canvas height
      const oScale = h / oh;
      const oW = ow * oScale;
      const oH = h;
      const odx = (w - oW) / 2;
      offCtx.drawImage(overlayImg, 0, 0, ow, oh, odx, 0, oW, oH);
    }

    // finally copy offscreen to visible canvas
    ctx.clearRect(0,0,w,h);
    ctx.drawImage(off, 0, 0, w, h);

    drawLoopId = requestAnimationFrame(drawLoop);
  }

  drawLoop();
}

/* Stop draw loop */
function stopDrawLoop(){
  if(drawLoopId) {
    cancelAnimationFrame(drawLoopId);
    drawLoopId = null;
  }
}

/* ======= EVENTOS / CONTROLES ======= */

/* 1) Ativar c√¢mera (bot√£o inicial) */
enableBtn.addEventListener('click', async () => {
  try {
    // small touch / click unlock protections
    document.addEventListener('touchstart', ()=>{}, {passive:true});
    document.addEventListener('click', ()=>{}, true);

    await startCamera();
    // start the draw loop so canvas shows live preview (draws video + overlay)
    startDrawLoop();

    // esconder bot√£o e mostrar UI √© feito na startCamera
    enableBtn.style.display = 'none';
  } catch (err) {
    console.error('Erro ao iniciar c√¢mera:', err);
    alert('Erro ao acessar a c√¢mera: ' + (err && err.message ? err.message : err));
  }
});

/* 2) Trocar c√¢mera */
btns.switchCamera.addEventListener('click', async () => {
  usingFront = !usingFront;
  // restart camera to switch facingMode
  try{
    await startCamera();
    // restart draw loop with new mirroring
    stopDrawLoop();
    startDrawLoop();
  } catch(e){
    console.error('Erro ao trocar c√¢mera', e);
    alert('Erro ao trocar c√¢mera: ' + e.name);
  }
});

/* 3) Capturar foto */
btns.capture.addEventListener('click', () => {
  if (!canvas.width || !canvas.height) { alert('Aguardando v√≠deo...'); return; }

  // create a temporary canvas with the same dimensions and get data URL
  const tmp = document.createElement('canvas');
  tmp.width = canvas.width;
  tmp.height = canvas.height;
  const tctx = tmp.getContext('2d');

  // draw current canvas to tmp (already contains video+overlay)
  tctx.drawImage(canvas, 0, 0);

  // show preview image
  const dataUrl = tmp.toDataURL('image/png');
  btns.previewVideo.style.display = 'none';
  btns.photoPreview.style.display = 'block';
  btns.photoPreview.src = dataUrl;
  btns.previewContainer.style.display = 'flex';
  showStatus('Foto pronta', true);
});

/* 4) Gravar (iniciar) */
btns.record.addEventListener('click', async () => {
  if (!canvas.width || !canvas.height) { alert('Aguardando v√≠deo...'); return; }

  // ensure drawing loop running
  if (!drawLoopId) startDrawLoop();

  // captureStream from canvas
  const canvasStream = canvas.captureStream(30);

  // add audio track from camera stream if available
  if (stream && stream.getAudioTracks().length) {
    canvasStream.addTrack(stream.getAudioTracks()[0]);
  }

  // choose mimeType
  const mime = getSupportedMime();
  let options = {};
  if (mime) options.mimeType = mime;

  try {
    recordedChunks = [];
    mediaRecorder = new MediaRecorder(canvasStream, options);

    mediaRecorder.ondataavailable = (e) => {
      if (e.data && e.data.size) recordedChunks.push(e.data);
    };

    mediaRecorder.onstart = () => {
      showStatus('Gravando...');
      btns.record.style.display = 'none';
      btns.stopRecord.style.display = 'inline-block';
    };

    mediaRecorder.onstop = async () => {
      showStatus('Convertendo para MP4 (pode demorar)...');
      // montar blob webm
      const webmBlob = new Blob(recordedChunks, { type: recordedChunks[0]?.type || 'video/webm' });

      // converter para mp4 via ffmpeg.wasm
      try {
        const mp4Blob = await convertWebmToMp4(webmBlob);

        const url = URL.createObjectURL(mp4Blob);
        btns.previewVideo.src = url;
        btns.previewVideo.style.display = 'block';
        btns.photoPreview.style.display = 'none';
        btns.previewContainer.style.display = 'flex';
        showStatus('Pronto!', true);
      } catch (e) {
        console.error('Erro convers√£o ffmpeg', e);
        // fallback: mostrar webm direto
        const webmUrl = URL.createObjectURL(webmBlob);
        btns.previewVideo.src = webmUrl;
        btns.previewVideo.style.display = 'block';
        btns.photoPreview.style.display = 'none';
        btns.previewContainer.style.display = 'flex';
        showStatus('Grava√ß√£o pronta (formato webm). Convers√£o falhou.', true);
      } finally {
        btns.record.style.display = 'inline-block';
        btns.stopRecord.style.display = 'none';
      }
    };

    mediaRecorder.start();
  } catch (err) {
    console.error('Erro MediaRecorder:', err);
    alert('N√£o foi poss√≠vel iniciar grava√ß√£o: ' + (err.message || err.name));
  }
});

/* 5) Parar grava√ß√£o */
btns.stopRecord.addEventListener('click', () => {
  if (mediaRecorder && mediaRecorder.state !== 'inactive') {
    mediaRecorder.stop();
    showStatus('Parando grava√ß√£o...');
  }
});

/* 6) Salvar (foto ou v√≠deo) */
btns.save.addEventListener('click', () => {
  // preferir v√≠deo se estiver vis√≠vel
  if (btns.previewVideo.style.display !== 'none' && btns.previewVideo.src) {
    const a = document.createElement('a');
    a.href = btns.previewVideo.src;
    a.download = 'video.mp4';
    a.click();
    showStatus('Download iniciado', true);
  } else if (btns.photoPreview.style.display !== 'none' && btns.photoPreview.src) {
    const a = document.createElement('a');
    a.href = btns.photoPreview.src;
    a.download = 'foto.png';
    a.click();
    showStatus('Download iniciado', true);
  } else {
    alert('Nada para salvar.');
  }
});

/* 7) Retry (voltar) */
btns.retry.addEventListener('click', () => {
  btns.previewContainer.style.display = 'none';
  btns.previewVideo.pause();
  btns.previewVideo.src = '';
  btns.photoPreview.src = '';
  showStatus('', false);
});

/* ======= Convers√£o WEBM -> MP4 com FFmpeg.WASM ======= */
async function convertWebmToMp4(webmBlob) {
  // carrega ffmpeg se necess√°rio
  if (!ffmpeg.isLoaded()) {
    showStatus('Carregando ffmpeg (pode demorar)...');
    await ffmpeg.load();
  }

  showStatus('Escrevendo arquivo para ffmpeg...');
  const data = await fetchFile(webmBlob);
  ffmpeg.FS('writeFile', 'input.webm', data);

  showStatus('Convertendo (ffmpeg) ‚Äî aguarde...');
  // -preset/params podem ser ajustados
  await ffmpeg.run(
    '-i','input.webm',
    '-c:v','libx264',
    '-preset','veryfast',
    '-c:a','aac',
    '-b:a','128k',
    'output.mp4'
  );

  showStatus('Lendo MP4...');
  const mp4Data = ffmpeg.FS('readFile','output.mp4');
  const mp4Blob = new Blob([mp4Data.buffer], { type: 'video/mp4' });

  // cleanup (optionally)
  try {
    ffmpeg.FS('unlink','input.webm');
    ffmpeg.FS('unlink','output.mp4');
  } catch(e){}

  return mp4Blob;
}

/* ======= Inicializa√ß√£o: esconder overlays de UI at√© ativar ======= */
(function initUI(){
  // ocultar todo elemento que possa interceptar toques at√© o usu√°rio ativar
  video.style.display = 'none';
  overlayImg.style.display = 'none';
  canvas.style.display = 'none';
  document.getElementById('buttons').style.display = 'none';
})();

/* ======= Observa√ß√µes finais =======
 - Se o usu√°rio negou permiss√£o anteriormente, o getUserMedia falhar√° com NotAllowedError.
 - FFmpeg.wasm √© pesado: no celular pode demorar (especialmente iPhone). Eu exibo status para o usu√°rio.
 - A moldura √© desenhada para preencher a altura (vertical) e √© centralizada horizontalmente preservando propor√ß√£o.
 - A c√¢mera frontal √© espelhada apenas no v√≠deo desenhado (se desejar tamb√©m espelhar a moldura, me avise).
====================================== */

</script>
</body>
</html>
